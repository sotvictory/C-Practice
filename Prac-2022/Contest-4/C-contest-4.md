# Задача 1: Виртуальная память
Рассмотрим модельный 16-битный процессор с 16-битным виртуальным и физическим адресным пространством, адресуемым побайтно, в котором реализована одноуровневая виртуальная страничная
адресация с размером страницы 512 байт. Процессор хранит целые числа в формате `Little-Endian`.

Первым аргументом командной строки передается бинарный файл размером 64KiB — содержимое
физической памяти. Вторым аргументом командной строки передается физический адрес начала
таблицы страниц в шестнадцатеричном виде.

Таблица страниц размещается в физической памяти, начиная с указанного адреса. Каждая запись
таблицы страниц имеет размер 16 бит, в которой старшие биты хранят номер физической страницы, а
младшие биты равны 0.

На стандартном потоке ввода задаются выровненные виртуальные адреса 16-битных ячеек памяти в
шестнадцатеричной записи. На стандартный поток вывода напечатайте значения, хранящиеся в
ячейках. Значения выводите в беззнаковом десятичном виде.

# Задача 2: Процессы
На стандартном потоке ввода задается целое число $N > 0$. Требуется создать $N - 1$ процессов так,
чтобы первый процесс (процесс-родитель) вывел на стандартный поток вывода число 1, второй процесс (его сын) вывел на стандартный поток вывода число 2,  третий — 3 и так далее.

Вывод должен быть таким, чтобы всегда на стандартном потоке вывода оказывалась последовательность $1\ 2\ 3\ ...\ N$, записанная в одну строку строго с одним пробелом между числами. В
конце вывода должен находиться символ `\n`. Дополнительные пробелы в начале или конце строки не
допускаются. Для вывода использовать средства высокого уровня.

Процесс-родитель должен завершаться самым последним из всех процессов.

Не используйте рекурсию!

# Задача 3: Условный запуск программ
Программе в аргументах командной строки передаются три команды для выполнения. Программа должна запустить на выполнение процессы, чтобы они выполнялись в конфигурации, соответствующей
команде Shell:

```
{ cmd1 || cmd2 } && cmd3
```

Родительский процесс должен дождаться завершения всех созданных им процессов и сам завершить
выполнение с кодом возврата 0 или 1 в зависимости от успешности выполнения процессов.

Команды `cmd1, cmd2, cmd3` можно запускать на выполнение с помощью `execlp`.

```
a || b := !a?b:true
a && b := a?b:false
{ } для группировки
```

Для шелла процесс считается завершившимся успешно, если процесс завершился с помощью
системного вызова `exit` (макрос `WIFEXITED` возвращает истинное значение), и код завершения процесса
(макрос `wexitstatus`) равен 0. В других случаях процесс считается завершившимся неуспешно. 

Соответственно, ваша программа должна завершиться с кодом 0 в случае успешного выполнения
заданной группы процессов и с кодом 1 в случае неуспешного их выполнения.

Организуйте вашу программу таким образом, чтобы избежать дублирование кода. В частности, запуск
процесса и проверка статуса его завершения может быть вынесена в функцию.

**Примечания по тестированию вашей программы:** Тестирование завершается с вердиктом
`'Synchronization error'`, если процесс-отец (то есть ваша программа, запускаемая на тестирование)
заканчивает работу раньше какого-либо из своих потомков.

# Задача 4: Конвейер
Программе в аргументах командной строки передаются три команды для выполнения, затем два имени
файла (всего 5 аргументов командной строки). Программа должна запустить на выполнение процессы,
чтобы они выполнялись в конфигурации, соответствующей команде shell:

```
( cmd1 < file1 && cmd2 ) | cmd3 >> file2
```

Родительский процесс должен дождаться завершения всех созданных им процессов и сам завершить
выполнение.

Считайте, что команды `cmd1, cmd2, cmd3`можно запускать на выполнение с помощью `execlp`.

Запись `cmd1 && cmd2` означает, что процесс `cmd2` должен быть запущен только после успешного
завершения процесса `cmd1`.

Запись `( cmd )` используется для группировки, при этом вся командная строка `cmd` выполняется в
отдельном процессе, порожденном основным процессом.

# Задача 5: Сигналы
Программе на стандартном потоке ввода задаются два целых числа low и high. Программа должна
вывести на стандартный поток вывода свой PID, после вывода программа должна обрабатывать
‘получение сигналов `SIGINT` и `SIGTERM`.

Программа должна вычислять простые числа в интервале $[low;high$). Если программа получила сигнал
`SIGINT`, программа должна вывести на стандартный поток вывода последнее на текущей момент
найденное простое число. При получении `SIGINT` в четвертый раз программа должна закончить работу с кодом завершения 0. Таким образом, может быть выведено не более трех простых чисел.

При получении сигнала `SIGTERM` программа должна завершиться с кодом 0.

Если программа закончила вычисления, программа должна вывести на стандартный поток вывода
число -1 и завершиться с кодом 0.

Если на момент прихода сигнала ни одно простое число найдено не было, выводите 0.

Учтите, что стандартный поток вывода программы будет перенаправлен в `pipe`.
