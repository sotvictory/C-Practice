# Команды

Все скомпилировать: `make` <br>
Все почистить: `make clean` <br>

Проверить на утечку файловых дескрипторов можно, например, так:
``` shell
cat > test.txt
sleep 10000
chmod +x test.txt
./prog ./test.txt
ps ax
ls -l /proc/<PID>/fd
```

Проверить дедлоки (посмотреть current call stack):
```
gdb <program> <PID>
bt
```

# Руденко:

`ioredirect.c` (8.18 d):
``` shell
pr1 < f.dat > f.res
```

`subshell.c` (8.18 h):
``` shell
((pr1 | pr2); pr3) | pr4
```

Проверить, например, на:
``` shell
# ((ls | sort); pwd) | sort
./subshell ls sort pwd sort
```

<span style="color:red; font-size: 1.5em;">? Deadlock </span> <br>
Есть еще `subshell_deadlock.c` с попыткой смоделировать скобки в отдельном процессе, но там возникает дедлок. <br>

Во-первых, `pr3` почему-то порождается не процессом `sub1`, а процессом `sub2`, как и процесс `pr4`, находящийся вроде как вне тела форков сабшеллов вообще, тоже порождается процессом `sub2`. <br>

Во-вторых, при подаче в прогамму `ls sort pwd sort` все процессы переходят в состояние `S+` из-за дедлока в сыне, который, если посмотреть соответствующий список вызовов в стеке, находится в `read` и соответственно ждет информацию для чтения (хотя вроде дексприпторы аккуратно закрывались), а отец -- соответственно в `wait` ждет сына. <br>

И я пока не знаю где ошибка =( <br>
Вероятно, здесь в целом неправильная схема порождения процессов. Либо неправильное перенаправление ввода/вывода в каналы.

# Казачук (синяя книга): 

 `cmd.c` (11.1 a):
 ``` shell
pr1 arg1 arg2 | pr2; pr3 >> f1.dat
 ```

  Проверить, например, на:
 ``` shell
 # ls -l -h | sort; pwd >> f1.dat
 ./cmd ls -l -h sort pwd f1.dat
 ```

 `conveyor.c` (11.1 c):
 ``` shell
 pr1 | pr2 | ... | prn
 ```

 Проверить, например, на:
 ``` shell
 # ls | cat | wc
 ./conveyor ls cat wc
 ```

`str_search.c` (11.4): <br>
Написать программу параллельного поиска подстроки в файлах, имена которых заданы в командной строке. Поиск подстроки в каждом из заданных файлов организовывать в процессе-потомке, создав для каждого файла свой процесс. Программа завершается, как только подстрока будет найдена в одном из файлов. Все незавершенные процессы должны быть прерваны.