# Task 3

Реализованна программа, которая создает частотный словарь для заданного текста. Текст, по которому строится словарь, вводится из `stdin`, а построенный словарь выводится в `stdout`.

Считывание из `stdin` производится до получения `EOF`. Строки могут быть произвольной длины. Считывание производится не посимвольно, а блоками фиксированной длины `BLOCK_SIZE` с помощью `read()`. 

## Алгоритм считывания:
1. Считывается очередные `BLOCK_SIZE` символов из входного потока в массив `stream_buf`
2. С помощью функции `get_sym()` получаем из `stream_buf` очередной символ. Если массив `stream_buf` исчерпался (`remaining_chars == 0`), то `get_sym()` считывает в `stream_buf` очередной блок данных и выдает следующий символ
3. Возвращаемый функцией `get_sym()` символ записывается в `buf` (текущее слово). Если `buf` оказывается полностью заполненным, то запрашивается новая память, по объему на `BUF_SIZE` большая. При достижении конца слова добавляется нуль-терминатор `'\0'`. Память выравнивается ровно под размер строки. Если слова в дереве нет, то оно добавляется с ключом `word`
   
## Реализованные функции: 
`mem_error()`: сообщает об ошибке выделения памяти и завершает работу программы с кодом ошибки 1; <br>

`print_tree()`: печатает слова в формате `слово число-вхождений частота-вхождений-слова` <br>
`print_tree_sorted()`: печатает те же слова, но в порядке убывания их частоты вхождений <br>
`destruct_tree()`: освобождает память, которая использовалась для хранения дерева <br>
`search_node()`: ищет в дереве звено, ключ которого совпадает с искомым словом `word`; <br>
возвращает 1, если такое звено было найдено, 0 в противном случае; <br>
также, если слово было найдено, в качестве побочного эффекта в рамках постановки задачи увеличивает `cnt` звена, в котором хранится слово, на 1 <br>
`add_node()`: добавляет звено с ключом `word`

`null_buf()`: обнуляет вспомогательные переменные для накапливания очередного слова <br>
`get_sym()`: описано в [алгоритме считывания](#алгоритм-считывания) <br>
`add_sym()`: описано в [алгоритме считывания](#алгоритм-считывания) <br>
`is_sep()`: возвращает 1, если символ `c` является разделителем, который нужно пропустить, 0 — в противном случае <br>
`is_word_char()`: возвращает 1, если символ `c` является символом, который может быть в слове, 0 — в противном случае <br>

## Граф, по которому построена программа:
![GRAPH](https://github.com/sotvictory/C-Practice/blob/1922510bd983ef0f3c8ebad2146cb415758fc7d1/Task-3/Graph.png)

## Замечание
В программе не предусмотрено распознавание кавычек, тире в виде `--` и прочих вещей, которые не зафиксированы в соответствующей данному графу грамматике